<!DOCTYPE html>
<html>
<head>
  <title>Connected Components Coreness</title>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
  <label for="scaleValue">Scala:</label>
  <input type="text" id="scaleValueX" value="1">
 
  <input type="text" id="scaleValueY" value="100">
  <button onclick="updateScale()">Scala</button>
  <button onclick="adjustScale(1)">+</button>
<button onclick="adjustScale(-1)">-</button>
  <div class="container" id="container"></div>
  <div id="my_dataviz"></div>
  <script> 
    let max_cin=0, max_cout=0, max_heat=0;  
    const margin = {top: 75, right: 75, bottom: 75, left: 75};
  
    // append the svg object to the body of the page
    
    // Inizializziamo le variabili per memorizzare i massimi di ciascuna colonna
    let maxX = 0;
    let maxY = 0;
    let maxHeat = 0;
    function adjustScale(amount) {
      var scaleValueInput = document.getElementById('scaleValue');
      var currentScale = parseFloat(scaleValueInput.value);
      
      // Incrementa o decrementa il valore della scala
      currentScale += amount;

      // Impedisce che il valore della scala sia inferiore a 1
      currentScale = Math.max(1, currentScale);

      // Aggiorna il valore nel campo di input
      scaleValueInput.value = currentScale.toString();
    }
    function updateScale(){
      const scaleValueInputX = document.getElementById('scaleValueX');
      const scaleValueX = parseInt(scaleValueInputX.value);
      const scaleValueInputY = document.getElementById('scaleValueY');
      const scaleValueY = parseInt(scaleValueInputY.value);
      localStorage.setItem('scaleValueX', scaleValueX);
      localStorage.setItem('scaleValueY', scaleValueY);
      window.location.reload();
      
    }
    
    function updateScaleVecchio(){
      const scaleValueInput = document.getElementById('scaleValue');
      const scaleValue = parseInt(scaleValueInput.value);
      localStorage.setItem('scaleValueY', scaleValueY);
      window.location.reload();
      
    }
    console.log("prima")
    document.addEventListener('DOMContentLoaded', function () {
      const storedScaleValueX = localStorage.getItem('scaleValueX');
      const storedScaleValueY = localStorage.getItem('scaleValueY');
      if (storedScaleValueX !== null) {
        document.getElementById('scaleValueX').value = storedScaleValueX;
      }
      if (storedScaleValueY !== null) {
        document.getElementById('scaleValueY').value = storedScaleValueY;
      }
    });
    console.log("dopo")
    // Utilizziamo d3.js per leggere il file CSV
    d3.json('matrix_degree.json').then(function(data) {
      
      //console.log(data)
      console.log("ok")
      var scaledData=[]
      var scaledData2=[]
      const scaleValueInputX = document.getElementById('scaleValueX');
      const scaleValueInputY = document.getElementById('scaleValueY');
      var scaleValueX = parseInt(scaleValueInputX.value);
      var scaleValueY = parseInt(scaleValueInputY.value);
    
      let k=0//Math.ceil(row.length/scaleValue);
       // Itera attraverso ogni riga nel dataset originale
        for(let h=0;h<data.length;h++){
          let row=data[h];
          let a
            for(let i=0; i<row.length;i+=scaleValueX){
              if(i+scaleValueX<row.length)
                a=i+scaleValueX
              else
                a=row.length
              scaledData[k]={
                
                x : i+"-"+(a-1),
                heat : row[i]
              };
              //console.log(scaledData[k])
              for(let j=i+1;j<i+scaleValueX && j<row.length;j++){
                scaledData[k].heat+=row[j]
              }
              k++;
            }
        }
        //console.log(scaledData)
        k=Math.ceil(data[0].length/scaleValueX)
        //console.log("k: "+k)
        for(let i=0; i< data.length;i+=scaleValueY){
          for(let j=i*k;j<(i+1)*k;j++){
            //console.log("j: ")
            //console.log(j);
            let a
            if(i+scaleValueY<data.length)
              a=i+scaleValueY
            else
              a=data.length
            scaledData[j].y=i+"-"+(a-1)
            //console.log("j: "+j+" k: "+k+" i:"+i)
            for(let h=(i+1)*k;h<(i+scaleValueY)*k && h<data.length*k;h+=k){
              //console.log("h: "+h)
              scaledData[j].heat+=scaledData[h+j-(i*k)].heat;
            }
            scaledData2.push(scaledData[j])
          }
        }
      console.log(scaledData2);
      scaledData2.forEach(function(d) {
        maxX = Math.max(maxX, parseFloat(d.x));
        maxY = Math.max(maxY, parseFloat(d.y));
        maxHeat = Math.max(maxHeat, parseFloat(d.heat));
      });
      calculate_HeatMap(maxX,maxY,maxHeat,scaledData2,scaleValueX,scaleValueY);
    }).catch(function(error) {
      // Gestione degli errori durante il caricamento del file
      console.error('Si è verificato un errore durante il caricamento del file:', error);
    });

    function calculate_HeatMap(maxX,maxY, maxHeat,data,scaleValueX,scaleValueY){
      console.log("Massimo di X:", maxX);
      console.log("Massimo di Y:", maxY);
      console.log("Massimo di Heat:", maxHeat); 
      var width =0;
      var height = 0
      width=maxX*10/scaleValueX  
      height=maxY*10/scaleValueY
      

      const svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", (width*4)+ margin.left + margin.right)
        .attr("height", (height*4) + margin.top + margin.bottom)
      .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
      let myGroups = [];
      let myVars = [];
      let i=0
      for(i=0; i<maxX/scaleValueX;i++){
        myGroups.push(i*scaleValueX+"-"+((i+1)*scaleValueX-1))
      }
      myGroups.push(i*scaleValueX+"-"+(maxX))
      console.log("myGroups")
      console.log(myGroups)
      /*
      for (let i = 0; i <= maxX; i++) {
        myGroups[i]=i.toString();
      }*/
      /*
      for(let i=0; i<data.length;i++){
        if(!myVars.includes(data[i].y)){
          myVars[i]=data[i].y.toString();
        }
      }
      myVars = myVars.filter(elemento => elemento !== "" && elemento !== null && elemento !== undefined);*/
      for(i=0; i<maxY/scaleValueY;i++){
        myVars.push(i*scaleValueY+"-"+((i+1)*scaleValueY-1))
      }
      myVars.push(i*scaleValueY+"-"+(maxY))
      console.log("myVars")
      console.log(myVars)
      /*
      for (let i = 0; i <= maxY; i++) {
        myVars[i]=i.toString();
      }*/
      // Build X scales and axis:
      const bandWidth = 5
      const x = d3.scaleBand()
        .range([ 0, (width*4) ])
        .domain(myGroups)
        .paddingInner(0.01) // Imposta il padding interno tra i tick dell'asse X
      svg.append("g")
        .attr("transform", `translate(0, ${height*4})`)
        .call(d3.axisBottom(x))
      
      // Build Y scales and axis:
      const y = d3.scaleBand()
        .range([ height*4, 0 ])
        .domain(myVars)
        .paddingInner(0.01) // Imposta il padding interno tra i tick dell'asse X
      svg.append("g")
        .call(d3.axisLeft(y));
      
      svg.append("text")
        .attr("transform", `translate(${width*4 / 2}, ${height*4 + margin.top-30 })`) // Posiziona l'etichetta dell'asse X
        .style("text-anchor", "middle")
        .style("font-size", "14px") 
        .text("INDEGREE");

        svg.append("text")
        .attr("transform", `translate(0, ${height*4 / 2}) rotate(-90)`)
        .attr("y", -margin.left + 20) // Aggiungi una regolazione per posizionare l'etichetta sopra l'asse y
        .style("text-anchor", "middle")
        .style("font-size", "15px") 
        .text("OUTDEGREE");
        /*const myScale = d3.scaleLog()
          .domain([1, maxHeat + 1]) // Assicurati di evitare il logaritmo di zero
          .range([0, 1]); // Range per la scala di colore predefinita di D3
          // Inverti l'ordine della scala di colore e utilizza un'altra funzione di interpolazione
        const myColor = d3.scaleSequential(d => d3.interpolateRdYlGn(1 - myScale(d))); // RdYlGn va dal rosso al verde
        
        
        */
        const myScale = d3.scaleLog()
        .domain([1, maxHeat + 1]) // Assicurati di evitare il logaritmo di zero
        .range([0, 1]); // Range per la scala di colore predefinita di D3
        //const myColor = d3.scaleSequential(d => d3.interpolateRdYl(myScale(d)));
        const myColor = d3.scaleSequential(d => d3.interpolateRdYlGn(1-myScale(d))); //verde scuro -> verde chiaro -> crema -> arancione -> rosso -> rosso scuro
        //const myColor = d3.scaleSequential(d => d3.interpolateViridis(myScale(d)));
        //const myColor = d3.scaleSequential(d => d3.interpolateMagma(myScale(d)));
        //const myColor = d3.scaleSequential(d => d3.interpolatePlasma(myScale(d)));
        //const myColor = d3.scaleSequential(d => d3.interpolateSpectral(myScale(d)));
        //const myColor = d3.scaleSequential(d => d3.interpolatePuOr(myScale(d)));
        //const myColor = d3.scaleSequential(d => d3.interpolateRdBu(myScale(d)));
        // Ora myColor sarà una scala di colori che va dal verde al rosso

        //Read the data
        var cout=0;
        svg.selectAll()
          .data(data, function(d) {
            return d.x+':'+d.y;
          })
          .join("rect")
          .attr("x", function(d) {return x(d.x)  })
          .attr("y", function(d) {return y(d.y) })
          .attr("width", x.bandwidth() )
          .attr("height", y.bandwidth() )
          .style("fill", function(d) {
            
            if(d.heat==0){
              return "white"
            }else {
              return myColor(d.heat);
            }
          });
    }
    
  
    </script>
</body>
</html>
